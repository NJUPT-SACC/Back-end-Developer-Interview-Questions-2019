# 操作系统常见面试题总结

1. 操作系统的定义以及操作系统具备的功能  
答:操作系统是控制和管理计算机系统内各种硬件和软件资源、合理有效地组织计算机系统的工作，为用户提供一个使用方便可扩展的工作环境，从而起到连接计算机和用户的接口作用
功能：大致包括5个方面的管理功能:进程与处理机管理、作业管理、存储管理、设备管理、文件管理。  

2. 进程与线程的区别  
答:  
    进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。  
    线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。  
    一个程序至少一个进程，一个进程至少一个线程。  

    两者的区别体现在：  
    地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。  
    资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程  
    执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。  
    线程是处理器调度的基本单位，但是进程不是。  
    两者均可并发执行。  
    优缺点：  
　　线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。  
　　进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。

3. 何时使用多进程，何时使用多线程？  
答:对资源的管理和保护要求高，不限制开销和效率时，使用多进程。  
   要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。  

4. 进程间通信的方式  
答:管道，FIFO（命名管道），消息队列，信号量+共享内存，套接字，信号  

5. Linux管道的使用  
答:管道是Linux由Unix那里继承过来的进程间的通信机制，它是Unix早期的一个重要通信机制。其思想是，在内存中创建一个共享文件，从而使通信双方利用这个共享文件来传递信息。由于这种方式具有单向传递数据的特点，所以这个作为传递消息的共享文件就叫做“管道”。

6. 共享内存实现  
答:共享内存是通过把同一块内存分别映射到不同的进程空间中实现进程间通信。而共享内存本身不带任何互斥与同步机制，但当多个进程同时对同一内存进行读写操作时会破坏该内存的内容，所以，在实际中，信号量。

7. 管道与共享内存的区别  
答:管道需要在内核和用户空间进行四次的数据拷贝：由用户空间的buf中将数据拷贝到内核中 -> 内核将数据拷贝到内存中 -> 内存到内核 -> 内核到用户空间的buf。而共享内存则只拷贝两次数据：用户空间到内存 -> 内存到用户空间。  
管道用循环队列实现，连续传送数据可以不限大小。共享内存每次传递数据大小是固定的；  
共享内存可以随机访问被映射文件的任意位置，管道只能顺序读写；  
管道可以独立完成数据的传递和通知机制，共享内存需要借助其他通讯方式进行消息传递。  
也就是说，两者之间最大的区别就是： 共享内存区是最快的可用IPC形式，一旦这样的内存区映射到共享它的进程的地址空间，这些进程间数据的传递，就不再通过执行任何进入内核的系统调用来传递彼此的数据，节省了时间。  

8. 信号量的作用  
答:信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作  

9. 死锁的条件与避免  
答: 死锁产生的4个必要条件  
    1、互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。  
    2、占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。  
    3、不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。  
    4、循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。  

    死锁的避免：  
    a、破坏“占有且等待”条件  
    方法1：所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。  
    优点：简单易实施且安全。  
    缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费。使进程经常发生饥饿现象。  
    方法2：该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。这样的话，资源的利用率会得到提高，也会减少进程的饥饿问题。  
    b、破坏“不可抢占”条件  
    当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。  
    该种方法实现起来比较复杂，且代价也比较大。释放已经保持的资源很有可能会导致进程之前的工作实效等，反复的申请和释放资源会导致进程的执行被无限的推迟，这不仅会延长进程的周转周期，还会影响系统的吞吐量。  
    c、破坏“循环等待”条件  
    可以通过定义资源类型的线性顺序来预防，可将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源。  
    这样虽然避免了循环等待，但是这种方法是比较低效的，资源的执行速度回变慢，并且可能在没有必要的情况下拒绝资源的访问，比如说，进程c想要申请资源1，如果资源1并没有被其他进程占有，此时将它分配个进程c是没有问题的，但是为了避免产生循环等待，该申请会被拒绝，这样就降低了资源的利用率  

    避免死锁的具体实现通常利用银行家算法  

10. 内存管理中的虚拟内存技术，是为了解决什么矛盾  
答:虚拟内存技术的核心就是利用了局部性原理，把所要运行的进程中的数据不全部加载到内存中执行，而是加载一部分，当CPU在请求页表时，发现缺页，就会把这个虚拟页从磁盘中调度到内存中（往往磁盘中的数据不常用，而在内存中的物理页的数据是频繁使用的数据），这样一来，我们就实现了多个进程同时加载到内存中并且还占用不是很多的内存的效果了  

11. linux有哪些常见的锁,各自有什么特点
答:互斥锁、读写锁、自旋锁等

12. 操作系统IO的几种类型和原理  
1）阻塞IO  
2）非阻塞IO  
3）IO复用（select和poll）  
4）信号驱动IO（sigio）  
5）异步IO（aio_）  

13. 孤儿进程和僵尸进程,如何避免僵尸进程  
答:孤儿进程:父进程退出，它的子进程就会成为孤儿进程，所有的孤儿进程都会被init接管，释放它们占用的系统资源。孤儿进程没有实质性危害。  
僵尸进程:进程通过fork创建子进程，如果子进程退出，父进程没有调用wait、waitpid等系统函数获取子进程的状态，那么子进程的描述符、进程号就会一直被占用，成为僵尸进程。  
很明显，僵尸进程会占用系统资源，过多的僵尸进程会导致进程号耗尽，无法创建新进程。  
相关机制:子进程退出后，系统会回收文件、内存等资源，但不会回收进程号，它要等到父进程调用wait后才会被释放。  
解决方法:子进程退出后，发送SIGCHILD信号，父进程在信号处理函数中调用wait接受子进程的状态。或者可行的话，直接杀死父进程，使子进程成为孤儿进程，由init进程接管。

14. 问题排查,比如cpu占用率高该怎么排查,遇到进程阻塞，进程僵死，内存泄漏等情况怎么排查  
答:通过top、jstack、日志、gui工具、Pprof(golang)、ps查询状态、分析dump文件等方式排查

15. 常见内存置换算法
答:LRU、FIFO之类的,部分公司会要求手写LRU算法

16. linux常用指令,比如查看端口占用、cpu负载、内存占用、查大文件某一行的内容等
答:熟悉ps、top、netstat、free、netstat、grep等常用指令
